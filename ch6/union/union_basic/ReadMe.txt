利用数字实现并查集的数据结构，通过索引访问数据，通过数组的内容判断两个索引是否是一组的
e.g. if id[p] == id[q], then p and q is a union.
将两个元素（索引）并起来的操作需要将索引对应的内容改成一致，在该实现中需要遍历整个数组.
所以并操作的效率并不高

改进1：
数组顺序结构查看两个节点连接与否很快O(1). 但是union节点操作需要访问整个数组O(n)
通过树形结构，如果两个节点具有同样的根节点，则认为这两个节点是union. 节点的内容存储的是父节点
索引，区别与之前认为的树形结构. 
判断两个节点是否相连通过判断它们是否具有相同的根节点
union操作通过将前一个节点的根指向后一个节点的根
改进之后在时间i消耗上有改进，但是也不是很理想. 主要问题是在union前后两个节点的根，应该将深度
小的树的根只想深度大的根的树，这样才能尽量减小union之后树的深度. 但是在程序中并没有做相应的判断

改进2：
在改进1的基础上，对uinon操作增加判断两个树深度的判断. 在实现上是通过增加一个数组sz[count], 
数组存储的是该节点为根的树的子节点个数. 将节点少的树添加到节点多的树上

改进3：
将改进2 中的sz数组改成rank数组. rank数组里存储的内容不再是以该节点为根的子树的节点数
而是以该节点为根的子树的层数

改进4：
对getRoot函数进行优化，路径压缩，两种方法来压缩路径，